include <pic.h>
/*   PIC Configuration Bit:
**   INTIO     - Using Internal RC No Clock
**   WDTDIS    - Wacthdog Timer Disable
**   PWRTEN    - Power Up Timer Enable
**   MCLREN    - Master Clear Enable
**   UNPROTECT - Code Un-Protect
**   UNPROTECT - Data EEPROM Read Un-Protect
**   BORDIS    - Borwn Out Detect Disable
**   IESODIS   - Internal External Switch Over Mode Disable
**   FCMDIS    - Monitor Clock Fail Safe Disable
*/
__CONFIG(INTIO & WDTDIS & PWRTEN & MCLREN & UNPROTECT \
  & UNPROTECT & BORDIS & IESODIS & FCMDIS);
// Using Internal Clock of 8 Mhz
#define FOSC 8000000L
// Servo definition and variables
#define MAX_VALUE 200
#define CCW_ROTATION MAX_VALUE - 20
#define CW_ROTATION MAX_VALUE - 10
#define STOP_ROTATION MAX_VALUE
#define THRESHOLD_VALUE 50
unsigned char pulse_max=0;		//Interrupt counter, it is incremented every 0.1 ms time elapsed
unsigned char pulse_top=0;		// It's the pulse counter
unsigned char top_value = 0;	//It's set the pulse hight time

/*
	Logic:


//Time to overflow
Ticks is the tmr0 value 

Tdelay=4*ticks*PRESC/fcl
			
				TIMER0 setting
		
INPUTS:
		fclk=8MHZ	PRESC=2	Tpwm=20 ms
		Tb: Time base=0.1 ms	The interrupt will occur every 0.1 ms

OUTPUTS:

ticks=Tb*fclk/(4*PRESC)=0.1e-3*8e6/(4*2)=100 	
	TMR0INI=255-100=155

	Then TMR0= 100 101 102 ... 255 .. 100 101
							   v
							   v
							   v Overflow

20ms means 20ms/0.1ms=200 interrupts 
		
	The pulse_max counter increments in each interruption , when it reach 200
it's value is set to 0 and	the pwm output:RC0 is set to low state



---------------------------------	
	Output voltage on pin RC2 (PWM)							  
	
		PWM 
					 High state duration=200-top_value=200-190=10 
					  ==> 10*0.1=1 ms
				|<--->|
				 High
            	 +---+        +---+
        	     |   |        |   |
      	Low    	 |   |        |   |
		---------|   ---------|   --
ms		0			 20
N		0        x   200
	
				 ^	 ^
				 |	 |			Restart time-base counters
				 |	 |------ pusle >=200 means pulse_max=0 pulse_top=0 , RC2=0
		         |													clear TOIF flag
				 |-----puse_top == top_value ==> RC2=1 High state
		

	N: Pulse duration in time base ticks
	x:high state duration in time base ticks


		PSEUDOCODE

		interruptisr(){
	
			IF(TOIF) then
				
				pulse_top++;
				pusle_max++;				

				if(pulse_max>200) then	// Restart counters
					RC2=0; pulse_max=0; pulse_top=0;			
				endif
				
				if(pulse_top==pulse_top)
					RC2=1
				endif
					
			endif


			TMR0=155
			TOIF=0
			
		}


	 main(){

		T0IE=1;	//Enable timer0 overflow interrupt
		GIE=1;	//Enable global interrupt
		Set_tmr0 prescaler 2	
		TMR0=155	// Start timer0
		
		pulse_max=0		//Initial state
		pulse_top=0
		
		while(1){
			update pulse_top // Control the servo position
		
		}

*/

static void interrupt isr(void)
{
  if(T0IF) {	            // TIMER0 Interrupt Flag
    pulse_max++;            // Pulse Max Increment
    pulse_top++;            // Pulse Top Increment

    /* MAX_VALUE=200 turn off the pulse */
    if (pulse_max >= MAX_VALUE) {
      pulse_max=0;
      pulse_top=0;
      RC2=0;                // Turn off RC2
    }

    /* top_value = MAX_VALUE - n, n=10: 10 x 0.1ms = 1.0ms, n=20: 20 x 0.1ms = 2.0ms */
    /* 2ms -> CCW Rotation, 1ms -> CW Rotation */
    if (pulse_top == top_value) {
      RC2=1;                // Turn On RC2
    }
    TMR0 = 156;             // Initial Value for 0.1ms Interrupt
    T0IF = 0;		    // Clear TIMER0 interrupt flag
  }
}
void main(void)
{
  unsigned char ldr_left;
  unsigned char ldr_right;
  int ldr_diff;
  OSCCON=0x70;         // Select 8 Mhz internal clock
  /* Initial Port Used */
  TRISC = 0x03;        // Set RC0 and RC1 as input others as Output
  ANSEL = 0x30;        // Set PORT AN4 and AN5 as analog input
  ANSELH = 0x00;       // Set PORT AN8 to AN11 as Digital I/O
  PORTC = 0x00;        // Turn Off all PORTC
  /* Init Servo Pulse */
  pulse_max=0;
  pulse_top=0;
  top_value = MAX_VALUE; // top_value = MAX_VALUE: Servo Motor Stop
  /* Initial ADC */
  ADCON1=0b00110000;   // Select the FRC for 8 Mhz
  /* Init TIMER0: Period: Fosc/4 x Prescaler x TMR0
     0.0005 ms x 2 * 100 = 0.1 ms */
  OPTION = 0b00000000; // 1:2 Prescaller
  TMR0=156;            // Interupt every 0.1 ms
  T0IE = 1;		       // Enable interrupt on TMR0 overflow
  GIE = 1;		       // Global interrupt enable

  for(;;) {
    /* Read the ADC here */
    ADCON0=0b00010001;       // select left justify result. ADC port channel AN4
    GODONE=1;	             // initiate conversion on the channel 4
    while(GODONE) continue;  // Wait for ldr_left conversion done
    ldr_left=ADRESH;         // Read 8 bits MSB, Ignore 2 bits LSB in ADRESL
    ADCON0=0b00010101;       // select left justify result. ADC port channel AN5
    GODONE=1;	             // initiate conversion on the channel 5
    while(GODONE) continue;  // Wait for ldr_right conversion done
    ldr_right=ADRESH;        // Read 8 bits MSB, Ignore 2 bits LSB in ADRESL

    /* Get the different */
    ldr_diff=ldr_left - ldr_right;    

    if ((ldr_diff >= -THRESHOLD_VALUE) && (ldr_diff <= THRESHOLD_VALUE)) {
      top_value = MAX_VALUE;     // Stop the Servo Motor
    } else {
      if (ldr_diff > THRESHOLD_VALUE) {
        top_value = CCW_ROTATION;  // Counterclockwise Rotation
      } else {
        top_value = CW_ROTATION;   // Clockwise Rotation
      }
    }
  }
}
/* EOF: servo.c */
