#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       robotlib.py
#       
#       Biblioteca de robotica
#       
#		      
# 
#       
from pylab import *


mm2in=1/25.4

# rpm para rad/s
rpm2rads=pi/30.0

# rad para rad/s
rads2rpm=30.0/pi

d2r=pi/180.0

r2d=180.0/pi




# Imprime matriz como o Matlab
def prm(M):

	M1=M.tolist()

	for MM in M1:
		s1="\t"
		for a in MM:
			s1=s1+"%.3f\t" % a
		#s1=s1
		print s1


def DH(theta,alpha,d,a):
	"""
	Argumentos
	[theta,alpha,d,a]

	*Obs:. Angulos em graus

	Computa parametros de Denavit-Hartenberg e retorna 
	matriz de tranformacao
       i-1
	 H  = DH(theta,alpha,d,a)
	  i
	
	i=1,2,3...
	theta=	angulo   (Xi-1/Xi)    - eixo  Zi-1
        alpha=	angulo   (Zi-1/Zi)    - eixo  Xi
	d=    	distancia(Xi-1/Xi)    -eixo   Zi-1
        a=	distancia(Zi-1/Zi)    -eixo   Xi
	"""
	theta=theta*d2r
	alpha=alpha*d2r
	
	H=matrix([[cos(theta),-cos(alpha)*sin(theta),\
	sin(alpha)*sin(theta),a*cos(theta)],[sin(theta), \
	cos(alpha)*cos(theta),-sin(alpha)*cos(theta),a*sin(theta)], \
	[0,sin(alpha),cos(alpha),d],[0,0,0,1]]);
	
	#print H

	#H=H.round()

        return H
        
        
        
def xyz(a):
	"""
	a: Tipo matriz
        Retorna componetes de um vetor
        [ax,ay,az]
	"""
	x=a.item(0)
	y=a.item(1)
	z=a.item(2)
	return [x,y,z]

def modl(a):
	"""
	Retorna mÃ³dulo de um vetor
	"""
	[x,y,z]=xyz(a)
	return sqrt(x**2+y**2+z**2)

def dotp(a,b):
	"""
	Produto escalar de dois vetores a.b=ax*bx+ay*by+az*bz
	Retorna a.b
	"""
	p=a.transpose()*b
	p=p.item(0)
	return p

def norm(a1,b1):
	"""
	Retorna vetor normal unitario a a1 e b1
	s=a1xb1/||a1xb1||
	[a1]: Vetor 3x1 - matriz
	[a2]: Vetor 3x1 - matriz
	[s]:Tipo matriz
	"""
	a=xyz(a1)
	b=xyz(b1)
	ax=a[0]
	ay=a[1]
	az=a[2]
	bx=b[0]
	by=b[1]
	bz=b[2]

	cx=ay*bz-by*az
	cy=-1*(ax*bz-az*bx)
	cz=ax*by-bx*ay

	c=[cx,cy,cz]
	c=matrix(c)
        val=modl(c)

	c=c.transpose()
	c=c/val
	c=c.round()
	return c



def atan2(y,x):
	"""
	Retorna atan(y/x)

	-180 a 180 deg

	"""

	qq1=atan(y/x)*180.0/pi
	qq1=abs(qq1)
	qq2=180-qq1

	if x>=0:
		return qq1*sign(y)
	if x<0:
		return qq2*sign(y)
	

	

def DHH(tab,verbose=1):
        T=tab
        HH=[]
	
	i=1

	for L in T:
		theta=L[0]  ;
		alpha=L[1] ;
		d=L[2]  ;
		a=L[3] ;
		H=DH(theta,alpha,d,a)   ;
		HH.append(H)
		if verbose:
			print "theta=",theta,"alpha=",alpha,"d=",d,"a=",a
			print "H%d=" % i
			prm(H)
			print "\n\n"
		i=i+1

	Htool=matrix(eye(4))

	for H in HH:
		Htool=Htool*H
	
	#Htool=Htool.round()
	return [HH,Htool]


def nsap(H):
        """
	H: Matriz 4x4  , tipo matrix
	
	criada por 

	H=[[1 ,2,3,4],[12,34,34....]]
	H=matrix(H)

	Extrai os vetores n:x , s:y , a:z 
	de uma matriz homogenea 4x4
	
            [   nx   sx   ax   px  ]  
	H=  [   ny   sy   ay   py  ]
            [   nz   sz   az   pz  ]
            [   0    0    0    1   ]
	
        Retorna , vetores coluna
	(n)3x1  (s)3x1  (a)3x1 (p)3x1
	Tipo matrix

        [n,s,a,p]

	"""

	n=H[:3,0] ;
	s=H[:3,1] ;
	a=H[:3,2] ;
	p=H[:3,3] ;

	return [n,s,a,p]

