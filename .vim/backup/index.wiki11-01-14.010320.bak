

= Teste1 =
== Teste2 ===
== Teste 3 ===
	*Texto1*
	-Italico-


	* Lista1 
	*	Lista3
	* Lista4
	* [Teste1]

	Creio que seja um problema de mapeamento das teclas do 
arquivo vimrc.


<br>Nenhum editor de texto faz o que o vim faz.Este editor tem
praticamente mais de 30 anos ,desde os tempos do UNIX só posso dizer
muito obrigado BRAMN MOOLENAR.

Script de autocompletação,super supra útil:
http://www.vim.org/scripts/script.php?script_id=2620

* []	Check box1
* [] 	Check Box2
* [X]	Mulher não é um microcontrolador.


Arquivos armazenados na rede local
http:localhost/files

Link para imagem local

<br> Outro Parágrafo

http://habamax.ru/blog/tag/vimwiki/


https://ccrma.stanford.edu/wiki/Example_Interfaces
https://ccrma.stanford.edu/wiki/Hardware_Lab
https://ccrma.stanford.edu/wiki/More_Sensors
https://ccrma.stanford.edu/wiki/250a_Firmware_Lab
https://ccrma.stanford.edu/wiki/250a_Microcontroller_%26_Sensors_Lab
http://blog.onaclovtech.com/2010/12/spi-vs-uart-vs-i2c-vs-four-event.html
http://fabrice.sincere.pagesperso-orange.fr/cm_electronique/projet_pic/aidememoire/usart628/usart628.htm#
http://royale.zerezo.com/talk/Mia09/PC.html
http://www.rose-hulman.edu/class/me/HTML/ME430_material/videos/ME430%20Le16%20ADC/ME430%20Le16%20ADC.html
http://www.rose-hulman.edu/class/me/HTML/ME430_material/videos/ME430%20Le16%20ADC/ME430%20Le16%20ADC.html
http://www.embeddedrelated.com/usenet/embedded/show/18343-1.php
http://www.ebah.com.br/programming-8-bit-pic-microcontrollers-in-c-with-interactive-hardware-pdf-a46915.html
http://www.oz1bxm.dk/PIC/16F628-UART-test.htm
http://www.microcontrollerboard.com/pic_serial_communication.html



C--PROGRAMING
http://cmagical.blogspot.com/2009/11/tips-for-programming-part5.html



Test your code by little pieces - write a little piece and test it. It makes easier to prevent "brain crashes" and guarantees that you're working from a stable code base. This means that you have bugs that are isolated to only the code you've recently been working on.


Clean up memory spaces that are no longer used. 

function_t(int val) 
{ 
char *msg = new char[30]; 

if(val == VALID) 
{ 
//do processing.... 
} 
else 
{ 
//don't just return.clean the memory that was alloted. 
delete [] msg; 
return false; 
} 
}



consider the operator ++ for the INT class just discussed.the reqirement is to have the operators , 
++a 
& 
a++ 

++a will be resolved as a.operator ++() 
a++ will be resolved as a. operator ++(0) 

In order to avoid this confusion , all postfix unary operators take in a dummy integer . 

Thus, 
++a will be resolved as a.operator ++() 
a++ will be resolved as a. operator ++(0) 


What Does {0} Mean in C?

Example code:

SHELLEXECUTEINFO sexi = {0};
sexi.cbSize = sizeof(SHELLEXECUTEINFO);
sexi.hwnd = NULL;
sexi.fMask = SEE_MASK_NOCLOSEPROCESS;
sexi.lpFile = lpFile.c_str();
sexi.lpParameters = args;
sexi.nShow = nShow;

if(ShellExecuteEx(&sexi))
{
DWORD wait = WaitForSingleObject(sexi.hProcess, INFINITE);
if(wait == WAIT_OBJECT_0)
GetExitCodeProcess(sexi.hProcess, &returnCode);
}


It is called aggregate initialization. Here is the (abbreviated) definition of an aggregate from section 8.5.1 of the ISO spec:

An aggregate is an array or a class with no user-declared constructors, no private or protected non-static data members, no base classes, and no virtual functions.

Now, using {0} to initialize an aggregate like this is basically a trick to 0 the entire thing. This is because when using aggregate initialization you don't have to specify all the members and the spec requires that all unspecified members be default initialized, which means set to 0 for simple types.

Here is the relevant quote from the spec:

If there are fewer initializers in the list than there are members in the aggregate, then each member not explicitly initialized shall be default-initialized. Example:

struct S { int a; char* b; int c; };
S ss = { 1, "asdf" };

initializes ss.a with 1, ss.b with "asdf", and ss.c with the value of an expression of the form int(), that is, 0.
Posted by Lakshmikandh at 5:02 AM
Labels: Structures






//------------------------------------------------

Hidden features of C

Function pointers. You can use a table of function pointers to implement, e.g., fast indirect-threaded code interpreters (FORTH) or byte-code dispatchers, or to simulate OO-like virtual methods.

Then there are hidden gems in the standard library, such as qsort(),bsearch(), strpbrk(), strcspn() [the latter two being useful for implementing a strtok() replacement].

A misfeature of C is that signed arithmetic overflow is undefined behavior (UB). So whenever you see an expression such as x+y, both being signed ints, it might potentially overflow and cause UB.


More of a trick of the GCC compiler, but you can give branch indication hints to the compiler (common in the Linux kernel)

#define likely(x) __builtin_expect((x),1)
#define unlikely(x) __builtin_expect((x),0)

see: http://kerneltrap.org/node/4705

What I like about this is that it also adds some expressiveness to some functions.

void foo(int arg)
{
if (unlikely(arg == 0)) {
do_this();
return;
}
do_that();
...
}


The comma operator isn't widely used. It can certainly be abused, but it can also be very useful. This use is the most common one:

for (int i=0; i<10; i++, doSomethingElse())
{
/* whatever */
}

But you can use this operator anywhere. Observe:

int j = (printf("Assigning variable j\n"), getValueFromSomewhere());

Each statement is evaluated, but the value of the expression will be that of the last statement evaluated.



How do you set, clear and toggle a single bit in C?

Setting a bit

Use the bitwise OR operator (|) to set a bit.

number |= 1 << x;

That will set bit x.

Clearing a bit

Use the bitwise AND operator (&) to clear a bit.

number &= ~(1 << x);

That will clear bit x. You must invert the bit string with the bitwise NOT operator (~), then AND it.

Toggling a bit

The XOR operator (^) can be used to toggle a bit.

number ^= 1 << x;

That will toggle bit x.

Checking a bit

You didn't ask for this but I might as well add it.

To check a bit, AND it with the bit you want to check:

bit = number & (1 << x);


========================================

What is the purpose of anonymous { } blocks in C style languages?

What is the purpose of anonymous { } blocks in C style languages (C, C++, C#)

Example -



void function()
{

{
int i = 0;
i = i + 1;
}

{
int k = 0;
k = k + 1;
}

}



Answer:

Brackets designate an area of scope - anything declared within the brackets is invisible outside of them.

Furthermore, in C++ an object allocated on the stack (e.g. without the use of 'new') will be destructed when it goes out of scope.

In some cases it can also be a way to highlight a particular piece of a function that the author feels is worthy of attention for people looking at the source. Whether this is a good use or not is debatable, but I have seen it done.
Posted by Lakshmikandh at 11:00 PM
Labels: general


========================================




= Embedded Syntax =
{{{class="brush: c"
#include "io.h"

int hello()
{

	return 0;
}

}}}
