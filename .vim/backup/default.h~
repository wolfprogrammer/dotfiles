/*! 
 *     @file default.h
 *     @author Caio Rodrigues
 *     @brief Implements all definitions and common data type 
 *
 *     \addtogroup DAFAULT  PERIPHERAL 
 *
 */
//\detail This file implements bit variable , integers data type , and useful macros.



#ifndef	_default_h_
#define _default_h_



///   \name Commmon Data Type Definitions
///   \brief Describes  unsigned and signed 8 , 16 and 32 bits data types which are useful in embedded programmming.
///
///  u<number> : Stands for unsigned
///  s<number> : Stands for signed
///
typedef unsigned char u8;   	///< 08   Bits unsigned int data type:   0  to 255
typedef unsigned int  u16;      ///<  16   Bits unsigned int data type:
typedef unsigned long u32;	///<  32   Bits unsigned int data type
typedef char s8;                ///<  08   Bits signed   int data type :  -127 to 128
typedef int  s16;  		///<  16   Bits signed   int data type
typedef long s32;		///<  32   Bits signed 	 int data type


/// \name Data ranges constants for unsigned int
#define MAXU8	0xFF
#define MAXU16	0xFFFF
#define MAXU32	0xFFFFFFFF
/// \name Data ranges constants for signed int
#define MAXS8	 128
#define MINS8	-127
#define MAXS16	 32767
#define MINS16  -32768

///  \name Strings and standard streams data type
///
typedef char *  string;



///   \struct  Flagbits_t
///   \brief  This struct implements 1 bit flag variable.
///   
///	Defines a FLAG VARIABEL - Bit Adressable  \
/// like 8051 to use them and can be considered a boolean type.
///  Put:  volatile Flagbits_t FLAGbits in the main code
///
///   Defines 8 flag bits from   Flagbits_t.F0 to Flagbits.F7
///
///   Example:
///   \code 
///   // In main.c put in the beggining of the file
///   #define "default.h"
///   voltatile FLAGbits_t  Flagbits;
///
///   // You can do:
///    Flagbits.F0=0;
///
///   #define BUTTON_PRESS F3
///   if(BUTTON_PRESS) ...
///
///   // Also
///   if(F0){ ... do something ...}
///  
///   FLAGS=0;  // All flags are 0.
///   F0=1; 
///   F7=0;
///   \endcode
///
typedef union {
        struct {
                unsigned F0         : 1; ///< Bit0 Flag bit 0
                unsigned F1         : 1; ///< Bit1 Flag bit 1 ... and so on
                unsigned F2         : 1; ///< Bit2 Flag bit 2 
                unsigned F3         : 1;
                unsigned F4         : 1;
                unsigned F5         : 1;
                unsigned F6         : 1;
                unsigned F7         : 1;
        };
	u8 FLAGS;                    ///< The variable that holds the valu of F7-F6-F5-...F0 bits

} FLAGbits_t;
extern volatile FLAGbits_t FLAGbits;

///  \name  Flag variabel definitios
///  \brief Creates the Flags variables to save memory
///
///
///
#define FLAGS FLAGbits.FLAGS
#define F0 FLAGbits.F0
#define F1 FLAGbits.F1
#define F2 FLAGbits.F2
#define F3 FLAGbits.F3
#define F4 FLAGbits.F4
#define F5 FLAGbits.F5
#define F6 FLAGbits.F6
#define F7 FLAGbits.F7





///  \name  Logical values definitions
#define  TRUE   1
#define  FALSE  0
#define  true   TRUE
#define  false  FALSE


/// \name  Common bit definitions
///
///
#define ON    1			
#define OFF   0			
#define HIGH  1			
#define LOW   0			
#define INP  1   		///<  Pin is input
#define OUT  0   		///<  Pin is output

///  \name Bit Values definitions
///  \brief Defines bit positions to set and clear 
///
///  Example Usage:
///  Set bits 7 and 6 and clear bit3 of MYVAR and toggle bit 1
///   \code
///    
///   MYVAR= MYVAR | bit7 | bit6 & ~bit3 ^ bit1
///
///  \endcode
///
#define bit0    1<<0
#define bit1    1<<1
#define bit2    1<<2
#define bit3    1<<3
#define bit4    1<<4
#define bit5    1<<5
#define bit6    1<<6
#define bit7    1<<7 

/// \name  Endless loop definition
#define  LOOP while(1)

/// \name Storage class 
/// Qualifier: The data will be stored in the ROM memory 
#define ROM __code	
//#define ROM code   % Only Old versions of SDCC




///  \name Bit operators
///
///  Implements  macros to bit mask operations
///
///  Example Usage:
///  \code
///  setb(TRISC,7) ; // It sets RC7
///  testb(PORTB,5); // If bit set return 1 , if bit not set returns 0
///
///  \endcode
///
// ---------- Bit Operations --------------------// 
#define  bitn(N)	 	(1<<N)
#define  setb(ADRESS,BIT)  	(ADRESS |=  (1<<BIT))	// Set bit
#define  clrb(ADRESS,BIT)  	(ADRESS &= ~(1<<BIT))   // Clear bit
#define  testb(ADRESS,BIT) 	(ADRESS &   (1<<BIT))   // Test if bit is set
#define  toggb(ADRESS,BIT)    	(ADRESS	^=  (1<<BIT))	// Toggle bit , turn on if bit is turned off , 
							// turn off if bit is turned off
							//
							//
#define inputpin(pin,port)  (pin=pin | (1<<port))
#define outputpin(pin,port) (pin=pin & ~(1<<port))
 

#define ALLCLEAR  0x00
#define ALLSET   ~0X00                                                  



/// \name ASM macros
// ASM macros
#define nop()   _asm NOP _endasm
#define sleep() _asm sleep _endasm
#define reset() _asm reset _endasm
#define clrwdt() _asm clrwdt _endasm
 

//-------------------------------------//
//	 INTERRUPT MACROS     	       //
//-------------------------------------// 


///   \name Interrupt Priority Table
///
// Interrupt Vector Table
#define RESET_ISR	0	// Reset ISR  		0X000000 
#define LOW_ISR		2	// Low 	 priority ISR   0X000018
#define HIGH_ISR	1       // Hight priority ISR	0x000008


///	\name Interrupt macros 
///     \brief This section implements macros to deal with interruts
// Interrupt Macros
//
// Global ISR
#define enable_all_isr()	setb(INTCON,7) //  GIE
#define disable_all_isr()	clrb(INTCON,7) // 
// Peripheral ISR 
#define enable_all_pir_isr()	setb(INTCON,6)   // PEIE
#define disable_all_pir_isr() 	clrb(INTCON,6)
// Receiver RX ISR
#define enable_receiver_isr() 	setb(PIE1,5) // RCIE
#define disable_receiver_isr()  clrb(PIE1,5) 
// Transmitter TX ISR



 


#endif  // default.h
