/*--------------------------------------------------------------------
          				delay.h										 


Caio Rodrigues Soares Silva


 	 Arquivo cabeçalho com de delays rotinas para microcontroladores 
  PIC


  
  Para usar este header ponha em main.c #include "delay.h" a rotina usada
depende da frequência do clock usado, frequências mais comuns são:
4 MHZ , 10 MHZ , 20 MHz.
 
 
 
 
---------------------------------------------------------------------*/

#ifndef _delay_h_
#define _delay_h_
#define __16f877a
#include "pic/pic16f877a.h"
#include "commdefs.h"


        /***************************************************
         *      Definições para os timers                  *
         *                                                 *
         **************************************************/




// Timer0 (8 bits) brescaler configurations
#define  tmr0_1b1      0b00001000	// Sem brescaler
#define  tmr0_1b2      0b00000000	// bréscaler de 1/2
#define  tmr0_1b4      0b00000001
#define  tmr0_1b8      0b00000010
#define  tmr0_1b16     0b00000011
#define  tmr0_1b32     0b00000100
#define  tmr0_1b64     0b00000101
#define  tmr0_1b128    0b00000110
#define  tmr0_1b256    0b00000111


/* Prescalers para o timer1(16 bits) */
#define tmr1_1b1      0b00000000
#define tmr1_1b2      0b01000000
#define tmr1_1b4      0b10000000
#define tmr1_1b8      0b11000000

// Configuração do clock,prescaler do tmer1(16 bits)
#define set_tmr1_clk(value) T1CON|=(value)
#define start_tmr1 TMR1ON=1   // Inicia o timer 1


// Retorna byte alto de uma variável de 16 bits
#define hbyte(val)  (val)>>8

// Retorna byte baixo de uma variável de 16 bits
#define lbyte(val)  (val)&0xFF


/*----------------------------------------------------
 *				void  setup_tmr0()
 *	What it do?	Start timer0 
 *	
 *	Input: Timer0 prescaler
 *
 *	This a function implemented as macro ,it's help the source code to be 
 *more readable
 *
 -----------------------------------------------------*/
#define  setupTmr0(PRESCALER)  OPTION_REG=(PRESCALER)




/*----------------------------------
        setup_tmr1

  Rotina para iniciar o timer1 com um dado
prescaler

arg: prescaler

O argumentos da função podem ser:

  tmr1_1b1  
  tmr1_1b2    
  tmr1_1b4
  tmr1_1b8

-----------------------------------*/


    void setup_tmr1(u8 prescaler){
    
        TMR1ON=0 ;          // Turn off TIMER1
        T1OSCEN=0;          // Disable Internal RC oscillator
        TMR1CS=0;           // Use Fosc/4 , external clock
        T1CON|=prescaler;   //
        TMR1ON=1;           // Start Timer1

    }



/*----------------------------------
            delay_tmr1()

 Delay com timer1(16 bits)
  
  O tempo de delay é de: 
  

  delay=ticks*tmr1*prescaler_tmr1*Tins
  Tins=FOSC/4
-----------------------------------*/




void delay_tmr1(u16 ticks){

    TMR1H=0;

    //Espera um periódo de ticks*presc*Tosc/4
    while((hbyte(ticks)!=TMR1L)|(lbyte(ticks)!=TMR1H)){}
   

}




        /***************************************************
         *      Rotinas de delays específicas para clocks  *
         *                                                 *
         **************************************************/

            /*--------------------------------
             *         CLOCK 4MHZ            *
             *                               *
             *  Rotinas para clock 4 MHZ     *
             *-------------------------------*/
#ifdef clock4mhz
#warning "Gravação para clock 4MHZ"

//				delay1s()
//
//	Espera 1 minuto
//
//	Memória de cálculo
//
//	   0_____	 Tc
//		|	|	|
//		|	|___|
//
//	Tc=4/Fclock=4/(4 MHZ)= 1us  : Tempo de instrução
//	Td=PRESC*Tc*TMR0*N=32*1us*250*125= 1 sec
//
void delay1s(void){

		u8 count1;
		OPTION_REG=tmr0_1b32;	//Clock 1 por 32 , prescaler de 32 
		TMR0=0;					//Inicia o TMR0

		for(count1=0;count1<125;count1++) while(TMR0<250);	

}


void delay10s(void){		//Base do tempo 1 segundo
		u8 countp;
			for(countp=0;countp<10;countp++) delay1s();

}


void delay_s(u8 countp){
		u8 i;
		for(i=0;i<countp;i++) delay1s();
	

}


void delay_ms(u8 N){

		u8 count1;
		OPTION_REG=tmr0_1b8;	//Clock 1 por 32 , prescaler de 32 
		TMR0=0;					//Inicia o TMR0

		for(count1=0;count1<N;count1++) while(TMR0<125);	


}


void delay_us(u8 N){
		
		u8 count1;
		for(count1=0;count1<N;count1++);
}

#endif


                /*--------------------------------
                 *         CLOCK 10MHZ           *
                 *                               *
                 *  Rotinas para clock 10 MHZ    *
                 *-------------------------------*/
#ifdef clock10mhz


#endif




                /*--------------------------------
                 *         CLOCK 20MHZ           *
                 *                               *
                 *  Rotinas para clock 20 MHZ    *
                 *-------------------------------*/
#ifdef clock20mhz


#endif


    //Delay em ms sem timers, note-se que se perde três registros
    void delay_ms(u8 ticks);






        




#endif
/*------------------------------------------------------------------
 *===============  End of delay.h ==================================
 *----------------------------------------------------------------*/



