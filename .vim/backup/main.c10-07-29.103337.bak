/*--------------------------------------------------------------
                main.c
  
ADC training project

PIC16F877A 4MHZ Clock

Caio Rodrigues Soares Silva

--------------------------------------------------------------*/


/* Processador de arquivo de cabeçalho */
#define __16f877a
#include "pic/pic16f877a.h"
#include "commdefs.h"



typedef unsigned int config;


config at 0x2007 __CONFIG= 
_WDT_OFF &		// Sem Watch dog timer 
_PWRTE_ON & 	// Com Power-On Reset
_BODEN_OFF &	// Com
_CP_OFF & 	    // Sem proteção do código
_DEBUG_OFF & 	// Sem debugger
_HS_OSC & 		// Oscilador cristal 4 MHZ
_CPD_OFF & 		//
_LVP_OFF; 		// Sem LVP:Low Voltage Programmming







//static void isr(void) interrupt 0{
//
//		T0IF=0; // Limpa a flag do interrupt do Timer0
//		PORTB++; //Incrementa PORTB
//}



void Delay1s(void);
static u8	disp7seg(u8 digit);


#if 0
__code  u8 LookUpTable[10]={
				0x3F,		// Disp 0
				0x06,		// Disp 1
				0x5B,		// Disp 2
				0X4F,		// Disp 3
				0x66,		// Disp 4
				0x6D,		// Disp 5
				0x7D,		// Disp 6
				0x07,		// Disp 7
				0x7F,		// Disp 8
				0x6F,		// Disp 9
				0x00		// Digito nulo se requerido
		};//End of LookUpTable
#endif



void main(){

		u8 Digito;
		u8 countp;

	CMCON=7;		  // Desabilita comparadores analógicos
	ADCON0=6;		  // Todas entradas analógicas desabilitadas
	INTCON=0;		  //Sem interrupção


	TRISB=0;		  // PORTB saída
	PORTB=0;


		while(1){/*Loop Para sempre*/
        

				for(Digito=0;Digito<10;Digito++){

				PORTB=disp7seg(Digito);				//Acende o display

					for(countp=0;countp<20;countp++){
						Delay1s();	//Espera 1 segundo
					}

				
				}
				

		} // End of while



} //end of main

/*----------------------------------------------------------*/



//Obs.: Para clock de 4MHZ
void Delay1s(void){

		u8 count1;
		OPTION_REG=tmr0_1p256;	//Clock 1 por 32 , prescaler de 32 
		TMR0=0;					//Inicia o TMR0

		for(count1=0;count1<125;count1++) while(TMR0<250);	

}



/*----------------------------------------------------------
					disp7seg

	Decodificador para o display de 7 segmentos

 Entrada: Digito
 Saída  : Código para acionar o display
-----------------------------------------------------------*/

#if 1
static u8	disp7seg(u8 digit){


		__code  u8 LookUpTable[10]={
				0x3F,		// Disp 0
				0x06,		// Disp 1
				0x5B,		// Disp 2
				0X4F,		// Disp 3
				0x66,		// Disp 4
				0x6D,		// Disp 5
				0x7D,		// Disp 6
				0x07,		// Disp 7
				0x7F,		// Disp 8
				0x6F,		// Disp 9
				0x00		// Digito nulo se requerido
		};//End of LookUpTable


return LookUpTable[digit];
}

/*	Este código não funcionou , preciso entender como o SDCC 
trata as classes de armazenamento.

Em assembly sei que funciona corretamente,
em C sei que a rotina do delay também funciona??? 
--------------------------------------------------

	Resolvido: Descobri que para a variável ser declarada como
constante na memória de programa usa-se a classe de armazenamento
__code

Mas a rotina de delay por alguma razão não funciona

*/

#endif



/*------------------------------------------------------------------
 ---------------------  END OF FILE --------------------------------
 ------------------------------------------------------------------*/
