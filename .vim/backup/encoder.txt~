====== ENCODERS ======

** Definiton ** \\
An encoder is an electromechanical device that can measure motion or position. 
Most encoders use optical sensors to provide electrical signals in the form of 
pulse trains, which can, in turn, be translated into motion, direction, or 
position.

	* Incremental(Realtive) : Measures change in position: velocity and acceleration
		* Velocity feedback
	* Absolute encoder : Measures absolute position
		* Position feedback
	* Quadrature encoder: Can detect the direction of motion
	* Linear encoder
	* Rotation encoder
	* Optical encoder: Uses a light source and a photo detector (Some cases IR sensor)
	* Hall effect encoder: Uses hall effect sensors to detect the rotation of a shaft.



===== INCREMENTAL ENCODERS =====


The encoder consists of light-emitting diod(LED) ,  a light dector and a disk .
The ligh can be IR-Infra-red radiation or the visible light. 
The disk, which is mounted on the rotating shaft, has patterns of 
opaque and transparent sectors coded into the disk. 
As the disk rotates, the opaque segments block the light and, 
where the glass is clear, light is allowed to pass. 
This generates **square-wave pulses**, which can then be interpreted into 
position or motion. 


{{ :instrumentation:encoder_wheel.png? |}}


\\
\\

{{ :instrumentation:encoder_waveforms.png? |}}



Uses two channnels A and B to sense position change. Uses two strips with sectors
are 90 degrees out of phase. The tho channels can indicate ,both, position and rotation.

	*  ** Quadrature Encoder** Can detect direction of motion uses two Channels A and B 
	*  A and B waveforms are 90 degrees ou of phase
	*  A leads B ==> The disk rotates in a clockwise direction 	  (CW)
	*  B leads A ==> The disk rotates in a counterclockwise direction (CCW)
	*  The position can be monitored by counting the number of pulses of A and B
	*  Encoders usually have from 100 to 6,000 segments per revolution. 
	*  Resolution= (360 degrees)/(Number of segments)=
		* 100 segments  Resolution = 360/100= 3.6 deg/segment
		* 6000 segments Resolution= 360/6000= 0.06 deg/segment
	* Some quadrature encoders( The absolute encoder) ; Has a third output channel , the zero,  reference signal, sometimes called Z-terminal or the index that supplies a single pulse for each revolution. This single pulse can be used for precise determination of a reference position.
	* Single Ended Encoder: A and B are referenced to the GND. There is one wire per channel.
	* Differential encoder: There are who lines per each A and B signal. The two lines are A' for signal A and B' for signal B. This type of configuration is also called push-pull because all four lines are always supplying a known voltage (either 0 V of Vcc). When A is Vcc, A’ is 0 V , and when A is 0 V, A’ is Vcc.



{{:instrumentation:optica3.gif?|}}  {{ :instrumentation:encode_direction.gif?|}}
\\
\\
\\
\\
\\
\\

==== ENCODER MEASUREMENT ====

To make the measurement it's needed a counter(event counter), our pulse acummulator. It can be found as single ic or a in the timer module of microcontroller that can work as a event counter.

The way by which edge counts are computed to position depends on the type of encoding used. 
\\ There are three basic types of encoding, X1, X2, and X4

{{ :instrumentation:x1_encoding.png? |}}
{{ :instrumentation:x2_encoding.png? |}}
{{ :instrumentation:x4_encoding.png? |}}


{{ :instrumentation:encoder-formulas.png? |}}



===== SELECTION ======

But, there is a better way.   Many processors have interrupt capabilities.  An interrupt is a hardware/software device which causes a software function to occur when something happens in hardware.  Specifically, whenever the detector A pulse goes high, the processor can be interrupted such that it suspends its ongoing navigation or motor control task, runs a special software routine (called an interrupt handler) which can compute the new distance traveled. When the interrupt handler is done, the processor automatically returns to the task it was working on when the interrupt occurred.   Sounds much easier doesn't it.  Actually, it takes more software to set it up, but it just does the job SO much better.

We'll get to some code examples in a bit, but first lets look at the logic which can be used to read the encoders.

With one detector:

    When leading edge of pulse occurs:
        IF (motor command is forward) THEN distance = distance + 1
        IF (motor command is reverse) THEN distance = distance -1

     Note that if the motor command is not forward or reverse, distance is not changed.  This avoids the possible problem of the robot stopping where the detector is right on the edge of a white strip and might be tripping on and off with no real motion. 

    Another problem is that if the motor is rolling along and is commanded to zero, it might coast a little before stopping.  The pseudo code above would miss the pulses that occur during coasting.  One way to minimize this problem is to slowly decelerate to a stop so there is little or no coasting after the motor is set to zero.

With two detectors (quadrature):

    When leading edge of pulse occurs:
        IF (detector B is high) THEN distance = distance + 1
        IF (detector B is low) THEN distance = distance -1

    This logic will count all wheel motion properly.  Even coasting after motor shutdown, and even if the motor is commanding reverse and the wheel happens to be going forward (probably more coasting).  The problem of stopping on the edge of a white sector still exists.  I haven't found it to be a problem, but it could be that the encoders I use take care of it with some hysteresis.

Improved resolution:

    The reflective sample encoder in the first picture on this page (right side) has 16 white sectors per revolution.  The counting schemes described so far count only transitions to a white sector so 16 counts per revolution is the best they can do.  
    Some processors (including my favorite the Motorola types like HC11 and HC12 series) can generate interrupts both when a signal goes high OR when it goes low OR for both high and low transitions.  This says that we can double the resolution of the encoder by counting both transitions.

This could be handled by two separate interrupts:

    When leading edge of pulse occurs:        (transition to high interrupt)
        IF (detector B is high) THEN distance = distance + 1
        IF (detector B is low) THEN distance = distance -1

    When trailing edge of pulse occurs:         (transition to low interrupt)
        IF (detector B is low) THEN distance = distance + 1
        IF (detector B is high) THEN distance = distance -1

Or by a single interrupt if it can be generated by either transition:

    When leading or trailing edge of pulse occurs:    (transition to high or low interrupt)
        IF (detector A is high AND detector B is high) THEN distance = distance + 1
        IF (detector A is high AND detector B is low) THEN distance = distance -1
        IF (detector A is low AND detector B is low) THEN distance = distance + 1
        IF (detector A is low AND detector B is high) THEN distance = distance -1
(I'm sure you can find more concise ways of coding this!!)

The ultimate:

    Now, if you were able to do interrupts on both high and low transitions, it is possible to add one (or two) more interrupts based on detector B (which switches half way between the detector A pulses) which will give double the distance resolution again.  I'll leave it to you to figure out the additional code required.  

Hardware:

    All these improved schemes aren't free (except for the software). 

The simplest pulse counter takes just one input pin (with interrupt capability) per encoder.

Adding quadrature for direction adds one more pin (no interrupt required).

Doubling the resolution by reading high and low transitions will require one more pin. Either another interrupt pin if you can't read high and low on the same pin), or another pin to read the status of the detector A signal.

And doubling the resolution again may require one or two more interrupt pins depending on whether you can read high and low on the same pin.

Of course, if you are reading the detectors by polling, I guess you can do it all with just two input pins.

If you made your own encoders:

   All the schemes above for doubling the encoder resolution depend on the output signals from the detectors being close to a square wave. This is because if you are going to measure distance from the leading edge to the trailing edge to the next leading edge, they should be equal distances apart.  A commercially available encoder will probably be square.
    But, if you made your own encoder, it could be that you are getting a short pulse during the white segment and a long pulse during the dark (or vice versa).  So, take a look at your pulses before assuming you can improve your resolution.

Computing Speed:

    Add this section someday!!!

Sample Code:


<code basic>
A program written by  for the Basic Stamp follows which shows a way to read single detector encoders from two wheels using polling. Go to Lior Elazary's website for more information on this program.
(download a better formatted version)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''
''' READING_ENCODERS.BS2 - Program to read the encoder
''' 
''' AUTHORS: Lior Elazary (lelazary@yahoo.com)
'''
''' LOG: 7/3/01 Created (Lior Elazary)
'''
'''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' Wheels Vars
Right_Wheel         Con 0     ' The right wheel pin connection
Left_Wheel           Con 1     ' The left wheel pin connection

Right_Encoder Var     IN2     ' The pin the right encoder is attached
Left_Encoder Var       IN3     ' The pin the left encoder is attached

Right_Stop     Con 650     ' The right stop value determined by simple.bs2
Left_Stop       Con 642

Right_Speed     Var Word
Left_Speed       Var Word

Right_Encode_Speed     Var byte
Left_Encode_Speed       Var word

Last_Right_Encoder       Var Bit
Last_Left_Encoder         Var Bit

Odom         Var word


X     Var byte
T     Var byte


Input 2
Input 3

Speed     Con 30

Move_Forward:
Right_Speed = Right_Stop - Speed         'Set the right and left speed
Left_Speed = Left_Stop + Speed
Odom = 0 ' Reset odometer

Move_Forward_Loop:
    Right_Encode_Speed = 0 'reset encode speed values
    Left_Encode_Speed = 0
    For x = 1 to 46 'loop 46 times to make about 1s
        pulsout Right_Wheel, Right_Speed 'set the servos speed
        Pulsout Left_Wheel, Left_Speed
        For t = 1 to 10 ' Loop 10 times to make ~21ms of loop 
            If Last_Right_Encoder = Right_Encoder THEN Cont_Right 'count changes from 1 to 0 and 0 to 1
                Last_Right_Encoder = Right_Encoder
                Right_Encode_Speed = Right_Encode_Speed + 1
            Cont_Right:
            If Last_Left_Encoder = Left_Encoder THEN Cont_Left
                Last_Left_Encoder = Left_Encoder
                Left_Encode_Speed = Left_Encode_Speed + 1
            Cont_Left:

        Next
Next                                                  ' ~1 sec total time for loop (21ms+1ms) * 46 = 1.012s 
pulsout Right_Wheel, Right_Speed     ' Set the servos speed again to give about 21ms for calculations
Pulsout Left_Wheel, Left_Speed

Odom = Odom + ((Right_Encode_Speed + Left_Encode_Speed) / 2)     ' Set the odometer to the average values of the two speeds

'''
''' Speed is at encode_speed/32 RPS
'''
debug "ODOM:", dec Odom, " RS:", dec Right_Encode_Speed, " ", dec (Right_Encode_Speed/32), " LS:", dec Left_Encode_Speed, CR 'Display results

Goto Move_Forward_Loop
</code>


And a program to read two encoders using interrupts on a Motorola 68HC912B32 is here
(again, download a better formatted copy)

The program defines two distance variables, odomL and odomR.  It has an interrupt for each of the left and right wheels.  These interrupts increment or decrement the odom counters based on the status of detector B.  The program also requires initialization of the timer to generate interrupts when encoder pulses are received.


<code c>
 /* Software for Ebot 7/10/01
Alex Brown rbirac@home.com 

written in ImageCraft ICC12 C for the Adapt912 board (68HC912B32)
This code extract shows how wheel encoders are run using interrupts
*/

/* I/O usage
13     PT0     Drive wheel encoder input A Left
12     PT1     Drive wheel encoder input A Right
11     PT2     Drive wheel encoder input B Left
10     PT3     Drive wheel encoder input B Right
*/

//Global Variable definitions

//Encoders
long int     odomL;     //raw count left encoder                           
long int     odomR;    //raw count right encoder
//---------------------------------------------------------------------------
//Drive wheel encoder interrupt Left (TC0)

void odom_handler_L(void)

{ TFLG1 = 0x01;                                           //Reset timer 0 interrupt flag   
if (PORTT & 0x04) odomL = odomL + 1;     //increment raw encoder count
else odomL = odomL - 1;
}
(return from interrupt)

//---------------------------------------------------------------------------
//Drive wheel encoder interrupt Right (TC1)

void odom_handler_R(void)

{ TFLG1 = 0x02;                                              //Reset timer 1 interrupt flag
if (PORTT & 0x08) odomR = odomR - 1;         //increment raw encoder count
else odomR = odomR + 1;
}
(return from interrupt)


/*---------------------------------------------------------------------------
Initialization of timer for encoders
TC0 used for drive wheel encoder left capture (chan A)
TC1 used for drive wheel encoder right capture (chan A)
TC2 used for drive wheel encoder left (direction, chan B)
TC3 used for drive wheel encoder right (direction, chan B)
*/
void timerinit()
{
TMSK1 = 0x03;             //enable timer interrupts TC0 & TC1
TMSK2 = 0x2B;            //disable overflow intr, enable pull ups,
                                       //prescale = 8, reset after OC7 compare
TCTL4 = 0x05;              //TC0 & TC1 to cap on rising edge
TSCR = 0x80;                //enable timer
}

main()
{
timerinit();                         //initialize timer

//---------------------------------------------------------------------------
// Control program

while (1)
{
/* Do any tasks in background mode. All of my control programs run under
a real time interrupt driven program, not shown.*/
};

return(0);
}
</code>

{{ :instrumentation:gray_code_encoder.png? |}}


===== REFERENCES =====

  * http://zone.ni.com/devzone/cda/tut/p/id/7109   The National Intruments explanation about rotary encoders
  * http://www.eehomepage.com/report.php?report=20080225
  * http://wiki.xtronics.com/index.php/EMC2
  * http://www.mindspring.com/~tom2000/Delphi/Codewheel.html  A lot of explanation about encoders. Code wheel generation ,algorithms...
  * http://hades.mech.northwestern.edu/index.php/Rotary_Encoder
  * Introduction to Mechatronics and Measurement Systems, Histand & Alciatore, 1999 McGraw Hill
  * http://www.bushytails.net/~randyg/encoder/encoderwheel.html  Encoder wheel generator
  * http://www.plansandprojects.com/My%20Machines/MouseHacking.html
  * http://members.shaw.ca/swstuff/mouse.html
  * http://eyal_abraham.tripod.com/sensors.htm
  * http://hackaday.com/2008/05/16/how-to-scavenge-a-mouse-for-parts/
  * http://www.linuxpcrobot.org/?q=node/3
  * http://www.eehomepage.com/report.php?report=20080225
