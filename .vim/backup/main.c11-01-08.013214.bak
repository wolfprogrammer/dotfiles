/*--------------------------------------------------------------
                main.c
  
PIC16F877A 4MHZ Clock

Caio Rodrigues Soares Silva

	Objetivo fazer o led em RB7 piscar usando-se interrupções
ne 1 em 1 segundo

--------------------------------------------------------------*/


/* Processador de arquivo de cabeçalho */

#define clock4mhz
#define __16f877a

#include "pic16f877a.h"
#include "commdefs.h"
#include "delay.h"
//#include "adc.h"



typedef unsigned int config;


config __at 0x2007 __CONFIG= 
_WDT_OFF &		// Sem Watch dog timer 
_PWRTE_ON & 	// Com Power-On Reset
_BODEN_OFF &	// Com
_CP_OFF & 	    // Sem proteção do código
_DEBUG_OFF & 	// Sem debugger
_HS_OSC & 		// Oscilador cristal 4 MHZ
_CPD_OFF & 		//
_LVP_OFF; 		// Sem LVP:Low Voltage Programmming


//Configuração do TIMER0
#define	T0INI	  98

// Dispositivo I/O
#define LED1 		RB0
#define LED1_tris	TRISB0

// Estados da máquina de elementos finitos
#define	LED1_ON		12
#define LED1_OFF	15

#define t1	100  // Valor para o task1


//	Estado atual , declarado volátil por que vai ser modificado 
//pela rotina de interrupção
//volatile u8 current_state;
volatile i8 time1;			//Timeout1

//Inicia a operação do programa
void start();

//Rotina de interrupção
static void isr(void) __interrupt 0;

void task1();



/*---------------------------------------------------------------+
|                         MAIN                                   |
+----------------------------------------------------------------+*/

void main(){                                                      

		start();


		while(1){/*Loop Para sempre*/
            
				if(time1==0) task1();
		
	    

				}//End of while



} //end of main

/*----------------------------------------------------------*/



/*         +--------------------------------+
		   |			start()             |
	       +--------------------------------+
*/
void start(){
		CMCON=7;		  // Desabilita comparadores analógicos
		ADCON0=6;		  // Todas entradas analógicas desabilitadas
		INTCON=0;		  //Sem interrupção

		LED1=0;			   //Limpa os latches
		LED1_tris=0;	   //Define como saída

		time1=t1;			//Inicia o contador do led
							// Quando time=0 , passaram-se 100*10ms=1 seg
							//

		//			Configuração do timer0
		//
		//		A interrupção por overflow do tmr0 acontecerá 
		//	para cada 1ms de delay 
		//
		//	Base do tempo 10 ms
		//
		//	N=157 T0INI=98	PRESC=64  Td=4*N*PRESC/Fclock=10.048 ms
		//
		setup_tmr0(tmr0_1b64,T0INI);	

		T0IE=1;		//Habilita interrupção para o TMR0
		GIE=1;		//Ativa as interrupções



} //End of start



/*         +--------------------------------+
		   |   static void isr __interrupt	|
	       +--------------------------------+
*/
static void isr(void) __interrupt 0{

		
		if(T0IF){

				if(time1>0) --time1;	//Qando time1 for0 para-se de decrementar
				
		}


		TMR0=T0INI; // Reseta o timer0
		T0IF=0;		//Limpa a flag do timer0

} //Fim da ISR



void  task1(){

		time1=t1;	//Reseta o time1
		LED1=LED1^1; //Inverte o estado lógico do LED

}



/*------------------------------------------------------------------
 ---------------------  END OF FILE --------------------------------
 ------------------------------------------------------------------*/
