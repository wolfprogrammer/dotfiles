#!/usr/bin/env python
# -*- coding: utf-8 -*-

import pdb

from robotlib import  *

RARM=+1
LARM=-1
ARMABOVE=+1
ARMBELOW=-1


# Angulo da terceira junata
def angt(a,b,c):
	"""
	Retorna cos de angulo de um triangulo cujo
	lado oposto seja a e os adjacentes a e b
	"""
	CA=(b**2+c**2-a**2)/(2*b*c)
	return CA  

def vec(x,y,z):
	"""
	Retorna vetor coluna 
	tipo matrix
	[x]
	[y]
	[z]
	"""
	v=[x,y,z]
	v=matrix(v)
	v=v.transpose()
	return v

def prlist(L,simb="q"):
	""" 
	Imprime lista com valores decimais
	"""

	i=1
	for a in L:
		print simb+"%d=%.3f" % (i,a) 
		i=i+1




def invk(Ht,ARM,ELBOW,WRIST=1):
	"""
	Encontra cinematica inversa
	de robo PUMA

	Ht: Matriz da ferramenta H06
	
	ARM: +1 Solucao braço direito  ( Right Arm)
	ARM: -1 Solucao braço equerdo  (Left Arm)
        
	ELBOW: +1 Braço acima  ( Above Arm)
	ELBOW: -1 Braço abaixo ( Below Arm)

	"""

	d2=1
	d4=1
	d6=1

	a2=1
	a3=1
	a4=1

	[n,s,a,p]=nsap(Ht)

  	pc=p-d6*a # Posicao do centro do punho
	[pcx,pcy,pcz]=xyz(pc)

	print "pc="; prm(pc)

	
	# Primeira junta q1
	R=sqrt(pcx**2+pcy**2)
	r=sqrt(R**2-d2**2)
	phi1=atan2(pcy,pcx)              
	alpha1=atan2(d2,r)

	if ARM==1:  
		q1= phi1-alpha1;  # Solucao braco direito
	
	if ARM==-1: 
		q1=phi1+alpha1+180;    # Solucao braco esquerdo (L:Left)

	# Angulo da segunda junta
	
	L3=sqrt(a3**2+d4**2)
	
	alpha2=atan2(pcz,r)
	R2=sqrt(pcz**2+r**2)
	
	Cb=(R2**2+a2**2-L3**2)/(2*R2*a2)
	Sb=sqrt(1-Cb**2)
	beta=atan2(Sb,Cb)
	
	if ELBOW==1:  
		q2=beta+alpha2     # Solucao braco abaixo
	
	if ELBOW==-1: 
		q2=beta-alpha2     # Solucao braco acima
	


	# Angulo da terceira junta
	#pdb.set_trace()

	Cphi=(a2**2+L3**2-R**2)/(2*a2*L3)      ;print Cphi
	Sphi=sqrt(1-Cphi**2)      ;print Sphi
	phi=180-atan2(Sphi,Cphi)   	;print phi

	beta=atan2(d4,a3)
        q3=beta+phi



	# Cinematica de orientacao
	dtab= [[q1, 90,  00, 00], [q2, 00, -d2, a2] , [q3, 90,  00, a3]]

	#dtab=matrix(dtab)

	[HH,H03]=DHH(dtab,0)
	print "H03=" ; prm(H03)

	[X3,Y3,Z3,P3]=nsap(H03)

	# Angulo da quarta junta q4
	Z4=norm(Z3,a)
	print "Z4="; prm(Z4)


	Y5=Z4
	k1=dotp(s,Y5)
	k2=dotp(n,Y5)

	if k1==0 :
		omega=k2
	else:
		omega=k1
	 
		
	M=WRIST*sign(omega)
	c4=M*dotp(Z4,Y3)
	s4=-M*dotp(Z4,X3)
	q4=atan2(s4,c4)

	H34=DH(q4,-90,d4,0)
	H04=H03*H34 
	
	[X4,Y4,Z4,P4]=nsap(H04)

        # Angulo da quinta junta q5

	S5=+dotp(a,X4)
	C5=-dotp(a,Y4)
        q5=atan2(S5,C5)

        H45=DH(q5,90,0,0)
	H05=H04*H45 
	
	[X5,Y5,Z5,P5]=nsap(H05)
         
	# Angulo da sexta junta q6

	S6=dotp(s,X5)
	C6=dotp(s,Y5)
	q6=atan2(S6,C6)

	return [q1,q2,q3,q4,q5,q6]


def fowardkin(q):
	"""
        Efetua cinematica direta do puma
	retorna matriz homogenia da ferramenta

	"""
	d2=1
	d4=1
	d6=1

	a2=1
	a3=1
	a4=1

	q1=q[0]
	q2=q[1]
	q3=q[2]
	q4=q[3]
	q5=q[4]
	q6=q[5]


	dhtable=[ \
	[q1, 90,  00, 00],  \
	[q2, 00, -d2, a2],  \
	[q3, 90,  00, a3],  \
	[q4,-90,  d4, 00],  \
	[q5, 90,  00, 00],  \
	[q6, 00,  d6, 00]]     


	[HH,Htool]=DHH(dhtable,0)

	print "Htool=";prm(Htool)





Ht=[[0,1,0,-1],[0,0,1,3],[1,0,0,1],[0,0,0,1]]
Ht=matrix(Ht)

print "Ht="; prm(Ht)

# Solucao1
ARM=1
ELBOW=-1
WRIST=1
print "Solucao"
print "ARM=",ARM
print "ELBOW=",ELBOW
print "WRIST=",WRIST
print "q=invk(Ht,ARM,ELBOW,WRIST)"
q=invk(Ht,ARM,ELBOW,WRIST)
prlist(q)
fowardkin(q)





print "\n\nSolucao"
ARM=-1
ELBOW=-1
WRIST=1
print "ARM=",ARM
print "ELBOW=",ELBOW
print "WRIST=",WRIST
print "q=invk(Ht,ARM,ELBOW,WRIST)"
q=invk(Ht,ARM,ELBOW,WRIST)
prlist(q)
fowardkin(q)

 

