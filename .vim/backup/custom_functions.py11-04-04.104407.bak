#!/usr/bin/env python
# -*- coding: UTF-8 -*-
from scipy import *
from pylab import *
import matplotlib.pyplot as plt

" Função seno com argumento em graus"
def sind(theta_deg):
		return sin(theta_deg*pi/180)


" Função coseno com argumento de graus"
def cosd(theta_deg):
		return cos(theta_deg*pi/180)

" Transforma um fasor rho<theta na forma retangular " 
def	r2p(rho,theta_deg):
		z=rho*(cosd(theta_deg)+1j*sind(theta_deg));
		return z

" Extrai a fase de um número complexo em graus"
def phase(z):
		return angle(z)*180/pi


" Sistema linear invariante no tempo"
"  ==>Linear Time Invariant System<=="
class LTI:
		NUM=array([])
		DEN=array([])
		p=array([]) 
		z=array([])
		L=0	

" Função de transferência"
def systf(NUM,DEN):
		G=LTI();
		G.NUM=NUM
		G.DEN=DEN
		L=G.NUM[0]
		G.L=L
#		G.z=roots(1/L*NUM)	## Dá erro
		G.z=roots(NUM)
		G.p=roots(DEN)
		sysout(G)
		return G

"Retorna ft em termos de pólos e zeros"
def syspz(ze,po,lead):
		G=LTI()
		G.p=po
		G.z=ze
		G.L=lead
		G.NUM=lead*poly(ze)
		G.DEN=poly(po)
		return G

" Determina o valor da tf em determinado ponto s"
def tfeval(G,s):
		A=polyval(G.NUM,s)
		B=polyval(G.DEN,s)
		return A/B


def sysout(G):
		print "NUM:",G.NUM
		print "DEN:",G.DEN
		print "z;",G.z
		print "p:",G.p
		print "L:",G.L

" Plota root locus da ft de transferência"
def rlocus(G,kmax):
	kk=arange(0,kmax,0.01)
	x=[]
	y=[]
	
	for k in kk:
			F=polyadd(polymul(k,G.NUM),G.DEN)   
			clrs=roots(F) 
			
			for crr in clrs:
					x.append(real(crr)); 
					y.append(imag(crr));

	scatter(x,y)
		#show()



" Computa os pontos de partida e chegada do rootlocis"
#def breakway():

def pzmap(G):
		"Polos de G"
		x1=real(G.p)
		y1=imag(G.p)
		"Zeros de G"
#		x2=real(G.z)
#		y2=imag(G.z)
		scatter(x1,y1,'X')
#		scatter(x2,y2)
		show()


"Gŕaficos de bode"
def bode(G,wmax):
		ww=logspace(-4,log10(wmax),100)
		V=[]
		theta=[]
		print round(wmax)
		print log10(wmax)
		
		for w in ww:
				F=tfeval(G,1j*w)
				V.append(20*log10(abs(F)))
				theta.append(phase(F))
		fig=plt.figure()
		ax=fig.add_subplot(1,1,1)
		ax.set_xscale('log')
		plt.plot(ww,V)
		plt.grid()
#		plot(ww,V)
		show()
#		print V
#		plot(ww,theta)



def feedback_block(G,H):
		NUM=polymul(G.NUM,H.DEN)
		DEN=polyadd(polymul(G.DEN,H.DEN),polymul(G.NUM,H.NUM))
		T=systf(NUM,DEN)
		return T

def serie_block(G,H):
		NUM=polymul(G.NUM,H.NUM)
		DEN=polymul(G.DEN,H.DEN)
		T=systf(NUM,DEN)
		return T

def ufeedback_block(G):
		NUM=G.NUM
		DEN=polyadd(G.NUM,G.DEN)
		T=systf(NUM,DEN)
		return T




def pointp(x,y):
		a=arange(x,x+1,1)
		b=arange(y,y+1,1)
		plot(a,b,'ro',ms=3)




def nyquist(G,wmax,N):
		ww=logspace(-4,log10(wmax),N)
		Gjw=[]   					#Vetor do mapeamento G(jw)=X(w)+kY(w)

		# w: omega de 0 a infinito
		for w in ww:
				GG1=tfeval(G,1j*w)
				print w
				Gjw.append(GG1)		#Acrescenta no fim do array Gjw o valor G(jw) calculado

		# w: omega de 0 a -infinito
		for w in ww:
				GG1=tfeval(G,-1j*w)
				print w
				Gjw.append(GG1)		#Acrescenta no fim do array Gjw o valor G(jw) calculado



#		for kk in Gjw:
#				print kk       #debug

		plot(real(Gjw),imag(Gjw))
		grid()




def nyquistpoints(G,ww):

		for w in ww:
				Q=tfeval(G,1j*w)
				X=real(Q)
				Y=imag(Q)
				annotate("w="+str(1j*w),xy=(X,Y))
				plot(X,Y,'ro',ms=6)					# Plota ponto vermelho 
													#em G(jw) em w=w0
				












# FIM DE ROOTLOCUS
#
